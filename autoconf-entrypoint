#!/usr/bin/env python3
import os
import json
import sys
import netifaces
import ipaddress
import shutil
import stat

from itertools import product

SUPPORTED_CERTS = {
    "ssl_ca_file": "client.ca.cert.pem",
    "ssl_cert_file": "server.cert.pem",
    "ssl_key_file": "server.key.pem",
}

# Environmental configuration
CERTS = json.loads(os.environ["CERTS"])
CONF_EXTRA = os.environ["CONF_EXTRA"]
LAN_AUTH_METHOD = os.environ["LAN_AUTH_METHOD"]
LAN_CONNECTION = os.environ["LAN_CONNECTION"]
LAN_DATABASES = json.loads(os.environ["LAN_DATABASES"])
LAN_HBA_TPL = os.environ["LAN_HBA_TPL"]
LAN_TLS = json.loads(os.environ["LAN_TLS"])
LAN_USERS = json.loads(os.environ["LAN_USERS"])
WAN_AUTH_METHOD = os.environ["WAN_AUTH_METHOD"]
WAN_CONNECTION = os.environ["WAN_CONNECTION"]
WAN_DATABASES = json.loads(os.environ["WAN_DATABASES"])
WAN_HBA_TPL = os.environ["WAN_HBA_TPL"]
WAN_TLS = json.loads(os.environ["WAN_TLS"])
WAN_USERS = json.loads(os.environ["WAN_USERS"])

# Configuration file templates
CONF_FOLDER = "/etc/postgres"
CONF_FILE = os.path.join(CONF_FOLDER, "postgresql.conf")
CONF_TPL = """
hba_file = '{conf_folder}/pg_hba.conf'
listen_addresses = '*'
{ssl_conf}
{extra_conf}
"""
HBA_FILE = os.path.join(CONF_FOLDER, "pg_hba.conf")
HBA_TPL = """
# Allow all local connections by socket
local all all trust
local replication all trust

# LAN/WAN autogenerated configurations
{extra_conf}
"""
WAN_CIDRS = ("0.0.0.0/0", "::0/0")

# Configuration helpers
hba_conf = []
ssl_conf = []


def permissions_fix(filename):
    """Make :param:`filename` be owned by root user and postgres group."""
    shutil.chown(filename, "root", "postgres")
    os.chmod(filename, stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP)


# Configure TLS
for key, filename in SUPPORTED_CERTS.items():
    full_path = os.path.join(CONF_FOLDER, filename)
    # Write PEM file if it came from env variable
    if not os.path.exists(full_path) and CERTS.get(filename):
        with open(full_path, "w") as cert_file:
            cert_file.write(CERTS[filename])
    if os.path.exists(full_path):
        # Enable file in postgres configuration
        ssl_conf.append("{} = '{}'".format(key, full_path))
        permissions_fix(full_path)

if ssl_conf:
    ssl_conf.append("ssl = on")

# Generate LAN auth configuration
for interface in netifaces.interfaces():
    for type_, addresses in netifaces.ifaddresses(interface).items():
        if type_ in {netifaces.AF_INET, netifaces.AF_INET6}:
            for address in addresses:
                try:
                    # Format interface IP and netmask in common CIDR notation
                    cidr = ipaddress.ip_network(
                        "{addr}/{netmask}".format(**address),
                        False,
                    )
                except ValueError:
                    continue
                # Append line to pg_hba.conf, according to template
                for user, db in product(LAN_USERS, LAN_DATABASES):
                    hba_conf.append(LAN_HBA_TPL.format(
                        connection=LAN_CONNECTION,
                        db=db,
                        user=user,
                        cidr=cidr,
                        meth=LAN_AUTH_METHOD,
                    ))

# Generate WAN auth configuration
for user, db, cidr in product(WAN_USERS, WAN_DATABASES, WAN_CIDRS):
    hba_conf.append(WAN_HBA_TPL.format(
        connection=WAN_CONNECTION,
        db=db,
        user=user,
        cidr=cidr,
        meth=WAN_AUTH_METHOD,
    ))

# Write postgres configuration files
with open(CONF_FILE, "w") as conf_file:
    conf_file.write(CONF_TPL.format(
        conf_folder=CONF_FOLDER,
        ssl_conf="\n".join(ssl_conf),
        extra_conf=CONF_EXTRA,
    ))
permissions_fix(CONF_FILE)
with open(HBA_FILE, "w") as conf_file:
    conf_file.write(HBA_TPL.format(
        extra_conf="\n".join(hba_conf),
    ))
permissions_fix(HBA_FILE)

# Continue normal execution
args = sys.argv[1:]
if not args or args[0] == "postgres" or args[0].startswith("-"):
    # Need to go through parent image entrypoint, and hardcode conf file
    args = [
        "/docker-entrypoint.sh",
        *args,
        "-cconfig_file={}".format(CONF_FILE),
    ]
os.execvp(args[0], args)
